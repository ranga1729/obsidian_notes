#### 3.1.1 Computer memory hierarchy
![[Pasted image 20250126221145.png]]
##### Primary memory
- Faster access.
- Limited storage.
- volatile.
- More expensive.
Ex: Main memory, Cache memory

1. Static RAM(SRAM)
	Cache memory in the CPU.
	Data kept as bits.
	The most expensive type. 
	Prefetching and pipelining techniques are used. 
	Speeds up the execution of program instructions for the CPU.
2. Dynamic RAM(DRAM)
	Main memory of a computer.
	CPU's space for storing application instructions and data.
	Low cost.(Compared to Static RAM)
	Less speed.(Compared to Static RAM)
##### Secondary memory
- Online storage solutions. (Like internal HDDs)
- CPU can't directly process data in secondary storage. They must be copied into primary storage first. 
Ex: Magnetic Disk, Flash drives, CD-ROM
- Mostly used for online storage of enterprise databases. 
- Less expensive.
- Measured in,
	Kilobytes(KB)
	Megabytes(MB)
	Gigabyte(GB)
	Terabyte(TB)
	Petabyte(PB)
##### Tertiary memory
- Removable media that can be used as offline storage.
- Large capacity.
- Comparatively less cost. 
- Slower access to data.(Compared to primary memory)
Ex: CD-ROMS, DVDs

1. Flash memory
	Non-volatile. 
	Categorized into EEPROM(Electronically Erasable and Programmable Read Only Memory)
	High performance.
	Fast access to data. 
	Disadvantage: Entire block must be erased and written simultaneously. 
	Two types, 
		1. NAND Flash Memory
		2. NOR Flash Memory
	Ex: USB flash drives
2. Optical Drives
	Ex: CDs and DVDs
	Capacity of a CD: 700mb
	Capacity of a DVD : 4.5 - 15GB
	
	CD-ROM(Compact Disk - Read Only Memory): Reads data by laser technology. Cannot be overwritten.
	CD-R(Compact Disk - Recordable) and DVD-R: Able to overwritten.
3. Magnetic Tapes
	Used for archiving and as a backup storage of data. 
	Magnetic Disks ranges: 400GB-8TB
	Magnetic Tapes ranges: 2.5Tb-8.5TB

#### 3.1.2 Storage Organization of Databases
- Databases store persistent data in the secondary memory. 
	Reasons,
	1. Non-volatile
	2. Large capacity
	3. Less cost per unit 
- Magnetic disks are wide used for database storages and Solid State Drives(SSD) are one of the latest alternative. 
- Magnetic tapes also used for database backup purposes. 
	Magnetic tapes required their data to be loaded and read before processing while magnetic disks can be accessed directly. 

- **Physical Database Design** is a process of selecting a data organizing technique for application requirements. 
- Data on disk is grouped into **Records** or **Files.**
- These records includes data about
	entities,
	attributes and 
	relationships.
- When a certain portion of the data is required, 
	1. It need to be found on the disk
	2. Copied to main memory for processing
	3. Rewritten to the disk of the data gets updated.
- Therefore, data should be kept on the disk in a way that they can be accessed quickly. 
##### Primary File Organization
Defines how the data is stored physically on the disk and how they can be accessed. 

| File Organization | Description                                                                     |
| ----------------- | ------------------------------------------------------------------------------- |
| Heap file         | No order. Appends new records to the end.                                       |
| Sorted file       | Maintain an order by sorting them on a particular field.                        |
| Hashed file       | Uses a hash function of a filed to identify the record's place in the database. |
| B Tree            | Uses tree structures for records storing.                                       |
#### 3.1.3 Secondary Storage Media
- HDD holds magnetics disks. 
- Basic unit of data in a HDD is the Bit.
	8 Bits = 1 Byte
	One character is stored using a 1 Byte. 
- **Capacity** of a disk : Number of Bytes it can hold.
- Disks are composed of magnetic material in the shape of a thin round disk.
- **Single sided disk** : Stores information only on one side.
- **Double sided disk** : Stores information on both sides.
- **Disk pack** is a pack of disks assembled together. 

![[Pasted image 20250127100835.png]]
- **Track** : Concentric circles of small width and with it's own diameter where information is stored on a disk. Numbered from outer edge to the inner edge of the disk.
- **Cylinder** : A group of tracks on different surface of a disk with the same diameter aligned together. 
- **Sector/Block** : Smallest units of data storage on a track which divides a track into fixed amount of data.
	![[d22a5711-2d48-495d-b86e-f31c37afcbf2_2000x1123.jpg]]
	Sector : Defined by the disk hardware and used by Disk controller directly when reading or writing occurs. 
	Block : A logical unit of storage defined by the file system(ex: NTFS, EXT4). and used by the OS/file system when reading or writing occurs.
##### Hardware components on a disk
![[Pasted image 20250127101605.png]]
![[Pasted image 20250127101729.png]]
##### Sector organizations on a disk
![[Disk+Storage+Devices+Different+sector+organizations+on+disk.jpg]]
- During the disk formatting, the OS divides a track into equal-sized disk **Block(or pages)**. Each block is size fixed and can not be adjusted dynamically. Block size is defined by the file system.


| ![[Pasted image 20250127104253.png]] | ![[Pasted image 20250127103227.png]] |
| ------------------------------------ | ------------------------------------ |


![[Pasted image 20250127103311.png]]
- **Interblock Gap** : Small empty space on a disk between two consecutive blocks(or sectors) on a track. 
	Ensures data block are physically separated and provides time for the read/write head to reset or prepare for the next block.
- **Hardware address of a block** : Uniquely identifies a physical location of a block on the disk. 
	Consist of,
	1. Cylinder Number : Specifies the vertical alignment of the block across platters.
	2. Track number : Surface number inside the cylinder on which the track is placed. Indicates which read/write head (platter surface) to use.
	3. Block number : 

> [!NOTE] Hardware address truly consist of,
> 1. Cylinder Number : Specifies the vertical alignment of the block across platters.
> 2. Head number : Indicates which read/write head (platter surface) to use.
> 3. Sector number : Specifies the sector on the track within the cylinder.
> Ex: `(Cylinder: 12, Head: 2, Sector: 20)`

- **Buffer** : Small, high-speed, memory area on the primary storage(DRAM) that temporarily hold data during read or write operations. 
	When data is read from the disk, it is first loaded into the buffer before being sent to the operating system. Data to be written is first stored in the buffer and then written to the disk.
- **Read commands** : Disk block is copied into the buffer.
- **Write command** : Content of the buffer are copied into the disk block.

![[Pasted image 20250127111329.png]]
- **Cluster** : A collection of contiguous blocks/sectors.
	Clusters simplify file system management by reducing the overhead of tracking individual sectors. Size of a cluster is depends on the file system. 
	Small files can waste space because even if a file is smaller than the cluster size, the entire cluster is allocated.
	Larger cluster sizes may lead to more wasted space (internal fragmentation), while smaller sizes increase file system overhead.
Ex: If a file is 6 KB in size and the cluster size is 4 KB, the file will use **2 clusters** (8 KB total) on the disk, leaving 2 KB of unused space.

##### Types of Read/Write heads,
![[Pasted image 20250127111840.png]]
1. Fixed Head disks : The read/write heads on disk units are fixed.
2. Movable Head disks : Disk units with an actuator connected to a second electrical motor that moves the read/write heads together and accurately positions them over the cylinder of tracks defined in a block address
	![[Pasted image 20250127112052.png]]

#### 3.1.3 Solid State Device Storage
- Known as "Flash storage".
- Store data without requiring constant power. 
- Internal components, 
	a controller,
	group of interconnected flash memory card
- SSDs can be plugged into slots designed for HDDs. 
- Since no moving parts in the SSD, it's
	more durable,
	run silently, 
	faster data access time, 
	better transfer rate
- Any address in SSD can be directly addressed compared to HDDS where block and cylinders should be pre-assigned.
- No restrictions on where data can be stored.
- With this direct access ability, data is less likely to be fragmented. No need for restructuring. 
- DRAM-Based SSDs also available addition to Flash memory. 
	DRAM-Based SSDs are more expensive, more faster and require internal power supply.
#### 3.1.5 Placing File Records on Disk
![[Pasted image 20250127162833.png]]
	Columns : Fields
	Rows : Records
	Each cell : value
	File : Sequence of records. (Usually all records in a file are in a same record type.)

- For a particular computer system, the number of bytes necessary for each data type is fixed.
	![[Pasted image 20250127163048.png]]
- Files can be in two types based on the types of records it contains,
	1. Fixed length records : All records in the file has the same size
	2. Variable length records : Different records of the file are of different sizes.
- Reason to have variable length records,
	Optional fields
	Some fields are of different sizes
	Some fields may have multiple values(Repeating group/filed)
	File includes different record type.(Mixed files)

- In a fixed length Record
	System can identify the ==starting byte location of each filed relative to the starting position of the record== since each record has equal fields and filed lengths.
	Variable length records can also be stored as fixed length records by
		1. Assigning "NULL" for optional fields.
		2. Assigning the maximum possible number of records for each repeating group. 
- In a variable length records,
	Each field in each record contains a value, but the precise length of some filed value is not correctly known. 
	To determine and terminate variable lengths special characters can be used. (Separators: `?`, `$`, `%`)
	They take up number of bytes for a particular record in each file. 

Ex: A fixed-length record with four fields and size of 44 bytes. 
**Entire record is fixed length, no record separator is required.** 
![[Pasted image 20250127172845.png]]

Ex: A record with two variable-length fields(Name and Department) and two fixed-length fields(NIC and Job_Code)
**Separator character is used to mark the record separation**.
![[Pasted image 20250127173057.png]]

Ex: A variable-field record with three types of separator characters. 
**The whole record is variable length. separators are required to mark the end of each filed as well the end of each record**.
![[Pasted image 20250127173428.png]]

#### Optimizations methods,
1. Record with optional fields,
**Problem** : In some records, all fields are not used and required. Storing empty or unused fields wastes space. 
**Solution** : Instead of storing all fields(including unused ones), you only store pairs of `<Field-Name, Filed-Value>`. A file is consist of series of these pairs. 

Ex: We have a records type for a user profile with following possible fields.
- Name, 
- Email, 
- Phone, 
- Middle Name(Optional)

Without optimization(Storing all fields),
```yaml
Name: John Doe
Email: john.doe@example.com
Phone: 1234567890
Middle Name: NULL
```
	Even thoug the middle is empty(NULL), it still occupies sotrage space. 
With optimization,
```yaml
Name: John Doe
Email: john.doe@example.com
Phone: 1234567890
```
	Fields are stored only when they have a value, reducing storage requirements.

Further optimization can be done by using **Field type codes** instead of including filed names in each and every record.(a predefined identifier for each field type)
The record will then store **<Field-Type, Field-Value>** pairs instead of the full field names, saving space.
Ex: 
- 1 = Name
- 2 = Email
- 3 = Phone
```yaml
01: John Doe
02: john.doe@example.com
03: 1234567890
04: 123 Main Street
```
	Field Type codes replace full field names for better efficiency.

2. Record with repeating fields
**Problem** : A record may include fields that have multiple values(repeating values, like a list of phone numbers). Without a clear structure, these values can be hard to interpret or process.
**Solution** : Use separator characters to organize repeated values.
- One separator to separate individual repeated values within the field.
- Another separator to mark the end of the field.
Ex: 
Without optimization,
```yaml
Order ID: 123
Products: Product1, Product2, Product3, Product4
```
	No clear structure to separate data.
With optimization,
```yaml
Order ID: 123
Products: Product1,Product2,Product3,Product4|
```
	Separator for individual values: `,` (comma)
	Separator to mark the field's end: `|` (pipe)

****
- **Block** is a unit data transfer between disk and memory.
When Block size > Record size,
	Several records may include in one block.
When Block size < Records size,
	One record can not fit into a single block.

- **Blocking Factor(bfr)** : Number of records(in bytes) can fit into a single disk block.
If Block size > Record size,
`bfr` can be calculated using, 
