- Used to speed up record retrieval in response to specific search criteria.
- Index structures are extra files on disk provides secondary access pathways.
- Index is created based on the **Indexing Field**.
- Any filed can be used to create an index, same file can have several indexes on separate fields or indexes on multiple fields at the same time. 

Types of indexes, 
1. Single Level Ordered Indexes
	- Primary index
	- Secondary index
	- Clustering index
2. Multi Level Tree Structured Index
	- B Tree
	- B+ Tree
3. Hash Index
4. Logical Index
5. Multi Key Index
6. Bitmap Index

### Single Level Ordered Index
- Organize and store the records of a table in a specific order based on one single column.(Indexing column)
- This indexes keeps entries sorted, typically in ascending or descending order. 
- Types,
	1. Primary
	2. Clustering
	3. Secondary
*****
#### 1. Primary Index
- Created automatically when a table is created and a primary key is defined.
- Defined for an ordered file using an **Ordering Key Field** and ordering has been done physically.
- Ordering key has unique values for each record. (ex: Primary key)
- If the ordering key is not unique, clustering index is applied when multiple records in the file have same value for the ordering field. 
	In this scenario, data file is referred as 'Clustered file'. 
	This scenario, it's not a primary index, it's a clustering index.
- A file can have ==only one physical ordering filed.==
	Therefore, a file can have one primary index or one clustering index. 
	I can not hold both primary and clustering index at once. 
![[Pasted image 20250128173640.png]]
- **Primary Index File** : A file with two fields and limited length generates when a primary index is created. 
	Two fields are, 
	1. Ordering Key field : Has the same data as the primary key column in the data file(table). (Ordered)
	2. A pointer to the disk block which contains relevant primary key field.
	Therefore, Index file contains one **index entry**(index record) for each block in the data file. 
Ex: Assume the "name" is the unique field and the name has been used to order the data file. We can create the primary index file as follows.
`K(i)` : Ordering key field, `P(i)` : Pointer to the data block
```
<k(1) = (Aron, Ed), P(1) = address_of_block_1>
<k(2) = (Adams, John), P(2) = address_of_block_2>
<k(3) = (Alexander, Ed), P(3) = address_of_block_3>

//K(i) values are in ordered manner in the Primary index file. But those records are scattered around the table in the data file.
```
![[Pasted image 20250128175528.png]]
- Considering the above table,
$\text{Number of Index Entries in the index file = Number of disk blocks in the data file}$
	Number of index entries in the index file not equal to the number of records in the data file. 
	Because one data block can include several data records.

- **Anchor Record/Block Anchor** : The first record in each data block of the data file.
	Each block has an anchor record. 
- One data block can have multiple records. 
- Pointers of the Primary index file points to the anchor record of the each block. (See the above image)

- **Dense Index** : Indexes that contains index entries for each **record** in the data file. 
- **Sparse Index** : Indexes that contains index entries for several records in the data file. (Because one data block can have multiple records)

- Therefore, Primary indexes falls into the sparse(non-dense) index type.
	Primary index keeps entries for anchor records for each block.

- Primary Index File takes smaller space due to,
	1. Number of index entries < number of records in the data file.
	2. Index entries only hold two fields.
- Therefore, Binary search algorithm causes less block accesses on an index file when compared to the binary search performed on a data file. 

The process of retrieving a record suing a primary index,
1. Perform binary search on the index file(Primary index file) to locate the particular key value we are looking for.
	Since the primary index is sorted, we can perform a binary search. 
	If the index file is spread across b number of blocks, the number of block accesses required for the search operation is $\log_{2}b$ 
	
	Suppose the index record with primary K is stored in **block P(i)**.
Index record is look like this,
	This satisfies the condition,
	$K(i) \leq K \lt K(i+1)$ 
	This means K lies between two index values, so it must be inside **block $i$**
	![[Pasted image 20250128202948.png]]
	All records of K(i) resides in the $i^{th}$ block.
2. Retrieve the Record
	Once we find the index entry, it provides the block address P(i).
	The system fetches the block P(i) from disk and retrieves the required record. 

Ex: 1. Non-indexed ordered file
Let's say we have an ordered file with its key fields. File records are fixed size and are unspanned.
Following details are given and we are going to calculate the block accesses require when performing a binary search.
	number of records(r) = 300,000
	block size(B) = 4096 bytes
	record length(R) = 100 bytes

Calculate the blocking factor(bfr)
	bfr = (B/R) = floor(4096/100) = 40 records block
Number of block needed to store all records
	b = (r/bfr) = ceiling(300,000/40) = 7,500 blocks
Block accesses required
	= $\lceil{log_{2}~b}\rceil$
	= $\lceil{log_{2}~7500}\rceil$
	= 13
Maximum 13 block accesses required to locate a particular record in the data file without using the index.

Ex: 2. For previous scenario given, if we have a primary index file with 9 bytes long ordering key field(V) and 6 bytes long block pointer (P), the required block accesses can be calculated as follows.
number of records(r) = 300,000
	block size(B) = 4096 bytes
	Index entry length($R_i$) = (V+P) = (9+6) = 15 bytes

Calculate the blocking factor for index records
	bfr = (B/R) = 4096/15 = 273 index records per block
Number of index entries required = Number of blocks required for data file.
Therefore, Number of index entries required to store the index file = 7500
Number of blocks needed for the index file,
	$b_i$ = (r/bfr) = ceiling(7500/273) = 28 blocks
Block accesses required
	= $\lceil{log_{2}~b_i}\rceil$
	= $\lceil{log_{2}~28}\rceil$
	= 5
To access the final record using the index, we have to access the data block points by the pointer in the index record we located using the binary search.
Total number of block accesses = $\lceil{log_{2}~b_i}\rceil$ + 1 = 6 block accesses

Problem with primary indexes, 
When adding a new record or deleting an existing record, existing records in the data file might subject to change their index.
Sometimes this change result in change of anchor records as well.
	An unordered overflow file can be used to scale down this problem.
	Adding a linked list of overflow records for each block in the data file is another way to address this issue. 
	Deletion markers can be used to manage the issues with record deletions.
*****
#### 2. Clustering Index
- **Clustered files** : A datafile ordered using a non-key field which does not consist of unique values. 
- **Clustering field** : The filed which is used to order the filed.
- Difference between primary index and clustering index is, primary index consist of distinct values while clustering index does not. 
- Clustering index also consist of two field, 
	1. Clustering field
	2. Block pointer
- In the index file, there's only one entry for distinct values in the clustering field with a pointer to the block where the first record corresponding to the clustering field appear. 
![[Pasted image 20250128231550.png]]
- Clustering key 2 first appears in the 1st block. Therefore, Index file's block pointer corresponds to the clustering key 2 points to the 1st block.

- Clustering index falls into **Sparse index** type since the index file contains entries for distinct values of the ordering key from the data file, rather than having index entries for each and every record in the data file.

Problems with clustering key,
- Since the data file is  ordered, entering and deleting records still causes problems in the clustering index as well they do in the primary index. 
- Common solution : Assign an entire block(or a set of neighbouring blocks) for each value in the clustering field. 
- All records that have similar clustering field will be stored in that allocated block. 
- This issue can be scaled down using an unordered overflow file.  
	Adding a linked list of overflow records for each block in the data file.
- Deletion markers can be used to handle deleting issue. 
![[Pasted image 20250128232710.png]]

Ex: 1. For the same ordered file with r = 300,000, B = 4,096 bytes, let’s say we have used a field “Zip code“ which is non key field, to order the data file.
Assumption: Each Zip Code has equal number of records and there are 1000 distinct values for Zip Codes ($r_i$). Index entries consist of 5-byte long Zip Code and 6-byte long block pointer.

Size of the index record($R_i$) = 5+6 = 11 bytes
Blocking factor($bfr_i$) = $\frac{B}{R_i}$ = floor(4096/11) = 372 index entries per block
Number of block needed to store the index($b_i$) = ceiling(1000/372) = 3 blocks
Blocks access to perform a binary search = $\lceil{log_{2}~b_i}\rceil$ = $\lceil{log_{2}~3}\rceil$ = 2
*****
#### 3. Secondary Index
- Provides and additional medium for accessing a data file which already has a primary access.
- Indexing filed of the secondary index can be,
	a candidate key(a set of columns in a relational database that uniquely identifies each row),
	non-key field
	redundant values
- Index file has two fields,
	1. Non-ordering Key field : Has the same data as the non-ordering field in the data file(table)
	2. A block pointer or a record pointer
- For a single file, few secondary indexes can be exist and each of them work as an additional method of accessing that file based a specific field. 
- For a secondary index created on a candidate key, which has unique values for every record in the file, the secondary index will get entries for every record in the data file.
	In this scenario, Secondary index act as a Dense index which holds key value and block pointer for each record in the data file.

- Same as the primary index, index entries are look like,
	`<K(i), P(i)>`
- Binary search can be performed, Since the order of the index file is based on the `K(i)`
- Block anchors are not useful in secondary index file because the data file is not physically ordered by the values of the secondary key field. 
	This is the reason to have index entries for each record in the secondary index file.

- Secondary index require more storage since it has index entries for each and every record of the data file. 
- Secondary index is important because we have to perform linear search without it on that particular field. 
	For the primary index, binary search can be performed even on the data file because it's physically ordered by the key field. 

- While primary and clustering index gives physical ordering to the data file, Secondary indexes give a **logical ordering** to the data file. 

Ex: If we take the same example in primary index and assume we search for a non-ordering key field V = 9 bytes long, in a file with 300,000 records with a fixed length of 100 bytes. And given block size B =4,096 bytes.

bfr = (B/R) = floor(4096/100) = 40 records per block
Number of blocks needed to store the data file = 300,000/40 = 7,500 blocks

If we perform linear search, 
	the required number of block access(on average) = 7500/2 = 3750 block accesses

If we have a secondary index on that non-ordering key filed, with entries for the block pointer P = 6 bytes long.
	length of an index entry = 9 + 6 = 15 bytes
	blocking factor(bfr) for the index file = B/R = floor(4096/15) = 273
Since the secondary index is dense, 
	number of index entries = number of records in the data file
	number of index entries = 300,000
number of block required for secondary index 
	b = r/bfr
	b = ceiling(300,000/273)
	b = 1099
if we perform binary search on the secondary index,
	number of block accesses required = $\log_{2}~1099$ = 11 block access
within 11 block accesses we can locate the key value we are looking for in the secondary index file. Then we can access it's pointer. 
	Total block access = 11 + 1 = 12 block access

*****
### Multilevel Indexes
![[Pasted image 20250129174801.png]]
- **First Level Index** is an index created to the original data file. 
- **Second Level Index** is an index created to the first level index.
- This indexing can go for multiple levels. 
A multi-level index can be created for any type of first level index(primary, secondary, clustering) as long as the first-level index consist of more than one disk block.
